<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring Basic - Bean</title>
    <link href="/2020/07/15/Spring-Basic/"/>
    <url>/2020/07/15/Spring-Basic/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Basic-Bean"><a href="#Spring-Basic-Bean" class="headerlink" title="Spring Basic - Bean"></a>Spring Basic - Bean</h1><p>The Spring framework consists of three core components:</p><blockquote><ul><li><strong>Context</strong><br>The role of Context is to discover the relationship between each Bean. And it will establish and maintain this relationship for beans. So Context is a collection of Bean relationships, this relationship combination is also known as the IOC container.  </li><li><strong>Core</strong><br>The role of the Core is to discover, establish and maintain a series of tools needed for the relationship between each Bean.</li><li><strong>Bean</strong><br>Bean is the most core component in Spring. In fact, Spring is Bean oriented programming(BOP). Spring wraps Object in Bean, and then implements a series of operations on Bean to achieve dependency injection(DI).  </li></ul></blockquote><p>This blog will mainly explain the generation mode and life cycle of Bean. After that, it can be easier to understand the implementation mechanism of Spring IOC.</p><h2 id="The-Generation-Mode-of-Bean"><a href="#The-Generation-Mode-of-Bean" class="headerlink" title="The Generation Mode of Bean"></a>The Generation Mode of Bean</h2><p>The creation of Spring Bean is a typical factory pattern. And the factory uses reflection technology to instantiate Bean. Compared with the ordinary factory model, the use of reflection technology can effectively improve the flexibility and maintainability of Spring source code.<br>First of all, let us take a look at the factory mode when <strong>reflection technology is not used</strong>.  </p><pre><code class="hljs bash">interface fruit&#123;    public abstract void eat();&#125; class Apple implements fruit&#123;     public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;         System.out.println(<span class="hljs-string">"Apple"</span>);     &#125;&#125; class Orange implements fruit&#123;     public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;         System.out.println(<span class="hljs-string">"Orange"</span>);     &#125;&#125;class Factory&#123;     public static fruit getInstance(String fruitName)&#123;         fruit f=null;         //Factory can product new <span class="hljs-built_in">type</span> instances by adding the following conditional statements         <span class="hljs-keyword">if</span>(<span class="hljs-string">"Apple"</span>.equals(fruitName))&#123;             f=new Apple();         &#125;         <span class="hljs-keyword">if</span>(<span class="hljs-string">"Orange"</span>.equals(fruitName))&#123;             f=new Orange();         &#125;         <span class="hljs-built_in">return</span> f;     &#125;&#125;//Using factory pattern to build instanceclass hello&#123;     public static void main(String[] a)&#123;         fruit f=Factory.getInstance(<span class="hljs-string">"Orange"</span>);         f.eat();     &#125;&#125;</code></pre><p>In the future, every time you want the factory to produce a new type instance, you need to override the factory method. If there are too many kinds of new subclasses to be added, the changes to the factory will be very large.<br>Next let us take a look at the factory mode when <strong>reflection technology is used</strong>.</p><pre><code class="hljs bash">interface fruit&#123;     public abstract void eat();&#125;class Apple implements fruit&#123;public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;         System.out.println(<span class="hljs-string">"Apple"</span>);     &#125;&#125;class Orange implements fruit&#123;public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;        System.out.println(<span class="hljs-string">"Orange"</span>);    &#125;&#125;class Factory&#123;    public static fruit getInstance(String ClassName)&#123;        fruit f=null;        try&#123;            //Construct a new instance from a string of class name            f=(fruit)Class.forName(ClassName).newInstance();        &#125;catch (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-built_in">return</span> f;    &#125;&#125;//Using factory pattern to build instanceclass hello&#123;    public static void main(String[] a)&#123;        //Enter string of class name        fruit f=Factory.getInstance(<span class="hljs-string">"Reflect.Apple"</span>);        <span class="hljs-keyword">if</span>(f!=null)&#123;            f.eat();        &#125;    &#125;&#125;</code></pre><p>After using the reflection technology, we no longer need to rewrite the factory method, the reflection technology will map the internal attribute method of the class into a Java object based on the bytecode information of the class. <strong>So this kind of factory model is more maintainable for developer</strong>. The IOC container uses this factory model and produces the objects we need according to the definition of the configuration file. But compared to the normal way of producing objects, the speed of reflection generation will be <strong>slower</strong>.</p><h2 id="Inversion-of-Control-IOC"><a href="#Inversion-of-Control-IOC" class="headerlink" title="Inversion of Control - IOC"></a>Inversion of Control - IOC</h2><p>IOC (Inversion of Control) contains two aspects: </p><blockquote><ul><li><strong>Control</strong><br>The control right of current object.</li><li><strong>Inversion</strong><br>This control right is not ever managed by the current object, but by IOC container.  </li></ul></blockquote><p>Simply put, the effect of IOC is to hand over the objects we need to a third-party IOC container to generate and we do not need to care about how they are produced. All we need to do is focus on the implementation of code logic. Compared to developers manually creating objects, IOC reverses the power of creating objects, that is, this power is assigned to Spring. Using IOC has the following benefits:  </p><blockquote><ul><li><strong>No need to create new objects by yourself, dependency injection(DI) can be done in IOC container.</strong></li><li><strong>The objects we need can be defined in the configuration file. Unified configuration, easy to modify.</strong>  </li></ul></blockquote><p>The IOC container is actually a relationship network about beans built by Context, Core and Bean. The entry point of this relationship construction is in the <strong>refresh</strong> method of the <strong>AbstractApplicationContext</strong> class. Code is showed as below:</p><pre><code class="hljs bash">public void refresh() throws BeansException, IllegalStateException &#123;synchronized (this.startupShutdownMonitor) &#123;// Prepare this context <span class="hljs-keyword">for</span> refreshing.prepareRefresh(); // Tell the subclass to refresh the internal bean factory.ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare beanfactory to use this context. Do some preparatory work, such as classloader, beanfactoryPostProcessor, etc.prepareBeanFactory(beanFactory); try &#123;//Allow subclasses of context to execute postProcessorpostProcessBeanFactory(beanFactory); // Start execution of BeanFactoryPostProcessors registered to this contextinvokeBeanFactoryPostProcessors(beanFactory); // Start registering BeanPostProcessor to intercept the initialization process of other beansregisterBeanPostProcessors(beanFactory); // Initialize the message <span class="hljs-built_in">source</span>initMessageSource(); //Register a broadcast <span class="hljs-built_in">set</span> of contextual eventsinitApplicationEventMulticaster(); //Initialize some special beansonRefresh(); //Query and verify the listener and registerregisterListeners(); // Instantiate all beans that are non-lazy-initfinishBeanFactoryInitialization(beanFactory); //Publish all applicationsfinishRefresh();&#125; catch (BeansException ex) &#123;// Destroy already created singletons to avoid dangling resources.destroyBeans(); // Reset <span class="hljs-string">'active'</span> flag.cancelRefresh(ex); // Propagate exception to <span class="hljs-built_in">caller</span>.throw ex;&#125;&#125;&#125;</code></pre><p>The IOC container is actually a big factory, which is used to manage all our objects and dependencies. The principle is as followsï¼š</p><blockquote><ul><li><strong>Through reflection we can get all the information of the class. That is, the bean is instantiated through the reflection factory pattern in the previous chapter.</strong>  </li><li><strong>Then describe the relationship between classes through configuration files or annotations.</strong></li><li><strong>Spring can automatically perform DI through the configuration of developer and reflection technology.</strong>  </li></ul></blockquote><h2 id="Spring-Container"><a href="#Spring-Container" class="headerlink" title="Spring Container"></a>Spring Container</h2><p>Spring container will be created in the <strong>refresh</strong> method. Now two Spring containers are defined, and the beans are actually produced from these two Spring containers:</p><blockquote><ul><li><strong>BeanFactory</strong><br>For the BeanFactory container, when a client requests a bean that has not been initialized from the container, or when another bean that needs to be injected uninitialized dependencies bean, the container will call <strong>createBean</strong> method to instantiate it. So very few resources are used when the application starts. But the application runs slower.</li><li><strong>ApplicationContext</strong><br>ApplicationContext implements the BeanFactory interface. Unlike BeanFactory, all the beans will be instantiated when the container is started. So it will take more time to start the application, but the application will run faster.  </li></ul></blockquote><p>The production process of beans in Spring containers:</p><blockquote><ul><li><strong>Create a bean definition registry inside the container based on the bean configuration information.</strong></li><li><strong>Load, instantiate beans according to the registry, and establish the dependency relationship between beans.</strong></li><li><strong>Put these ready beans in the Map cache pool and wait for the application to call.</strong>  </li></ul></blockquote><p>Almost all applications currently use <strong>ApplicationContext</strong>!  </p><h2 id="Bean-Life-Cycle"><a href="#Bean-Life-Cycle" class="headerlink" title="Bean Life Cycle"></a>Bean Life Cycle</h2><p>The Spring container can manage the life cycle of <strong>singleton</strong> scope beans. Under this scope, Spring can accurately know when the bean is created, when initialization is completed, and when it is destroyed.<br>But for Beans in <strong>prototype</strong> scope, Spring is only responsible for creating. When the container creates an instance of Bean, the instance of Bean is handed over to the client code management, and the Spring container will no longer track its life cycle. The Bean life cycle is shown in the figure below:<br><img src="/2020/07/15/Spring-Basic/Bean_life.png" srcset="/img/loading.gif" alt="Bean life cycle"></p><blockquote><ol><li>Invoke the bean construction method or factory method to instantiate the bean according to the configuration.</li><li></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blog Template</title>
    <link href="/2020/07/04/Blog-Template/"/>
    <url>/2020/07/04/Blog-Template/</url>
    
    <content type="html"><![CDATA[<h1 id="Title1"><a href="#Title1" class="headerlink" title="Title1"></a>Title1</h1><h2 id="Title2"><a href="#Title2" class="headerlink" title="Title2"></a>Title2</h2><h3 id="Title3"><a href="#Title3" class="headerlink" title="Title3"></a>Title3</h3><pre><code class="hljs bash">Equations Test</code></pre><div class="note note-success">            <p>This is test</p>          </div><span class="label label-primary">labeltest</span>]]></content>
    
    
    <categories>
      
      <category>TEST</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
