<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring Basic - Bean and IOC</title>
    <link href="/2020/07/15/Spring-Basic/"/>
    <url>/2020/07/15/Spring-Basic/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Basic-Bean-and-IOC"><a href="#Spring-Basic-Bean-and-IOC" class="headerlink" title="Spring Basic - Bean and IOC"></a>Spring Basic - Bean and IOC</h1><p>The Spring framework consists of three core components:</p><blockquote><ul><li><strong>Context</strong><br>The role of Context is to discover the relationship between each Bean. And it will establish and maintain this relationship for beans. So Context is a collection of Bean relationships, this relationship combination is also known as the IOC container.  </li><li><strong>Core</strong><br>The role of the Core is to discover, establish and maintain a series of tools needed for the relationship between each Bean.</li><li><strong>Bean</strong><br>Bean is the most core component in Spring. In fact, Spring is Bean oriented programming(BOP). Spring wraps Object in Bean, and then implements a series of operations on Bean to achieve dependency injection(DI).  </li></ul></blockquote><p>This blog will mainly explain the generation mode and life cycle of Bean. After that, it can be easier to understand the implementation mechanism of Spring IOC.</p><h2 id="The-Generation-Mode-of-Bean"><a href="#The-Generation-Mode-of-Bean" class="headerlink" title="The Generation Mode of Bean"></a>The Generation Mode of Bean</h2><p>The creation of Spring Bean is a typical factory pattern. And the factory uses reflection technology to instantiate Bean. Compared with the ordinary factory model, the use of reflection technology can effectively improve the flexibility and maintainability of Spring source code.<br>First of all, let us take a look at the factory mode when <strong>reflection technology is not used</strong>.  </p><pre><code class="hljs bash">interface fruit&#123;    public abstract void eat();&#125; class Apple implements fruit&#123;     public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;         System.out.println(<span class="hljs-string">"Apple"</span>);     &#125;&#125; class Orange implements fruit&#123;     public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;         System.out.println(<span class="hljs-string">"Orange"</span>);     &#125;&#125;class Factory&#123;     public static fruit getInstance(String fruitName)&#123;         fruit f=null;         //Factory can product new <span class="hljs-built_in">type</span> instances by adding the following conditional statements         <span class="hljs-keyword">if</span>(<span class="hljs-string">"Apple"</span>.equals(fruitName))&#123;             f=new Apple();         &#125;         <span class="hljs-keyword">if</span>(<span class="hljs-string">"Orange"</span>.equals(fruitName))&#123;             f=new Orange();         &#125;         <span class="hljs-built_in">return</span> f;     &#125;&#125;//Using factory pattern to build instanceclass hello&#123;     public static void main(String[] a)&#123;         fruit f=Factory.getInstance(<span class="hljs-string">"Orange"</span>);         f.eat();     &#125;&#125;</code></pre><p>In the future, every time you want the factory to produce a new type instance, you need to override the factory method. If there are too many kinds of new subclasses to be added, the changes to the factory will be very large.<br>Next let us take a look at the factory mode when <strong>reflection technology is used</strong>.</p><pre><code class="hljs bash">interface fruit&#123;     public abstract void eat();&#125;class Apple implements fruit&#123;public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;         System.out.println(<span class="hljs-string">"Apple"</span>);     &#125;&#125;class Orange implements fruit&#123;public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;        System.out.println(<span class="hljs-string">"Orange"</span>);    &#125;&#125;class Factory&#123;    public static fruit getInstance(String ClassName)&#123;        fruit f=null;        try&#123;            //Construct a new instance from a string of class name            f=(fruit)Class.forName(ClassName).newInstance();        &#125;catch (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-built_in">return</span> f;    &#125;&#125;//Using factory pattern to build instanceclass hello&#123;    public static void main(String[] a)&#123;        //Enter string of class name        fruit f=Factory.getInstance(<span class="hljs-string">"Reflect.Apple"</span>);        <span class="hljs-keyword">if</span>(f!=null)&#123;            f.eat();        &#125;    &#125;&#125;</code></pre><p>After using the reflection technology, we no longer need to rewrite the factory method, the reflection technology will map the internal attribute method of the class into a Java object based on the bytecode information of the class. <strong>So this kind of factory model is more maintainable for developer</strong>. The IOC container uses this factory model and produces the objects we need according to the definition of the configuration file. But compared to the normal way of producing objects, the speed of reflection generation will be <strong>slower</strong>.</p><h2 id="Inversion-of-Control-IOC"><a href="#Inversion-of-Control-IOC" class="headerlink" title="Inversion of Control - IOC"></a>Inversion of Control - IOC</h2><p>IOC (Inversion of Control) contains two aspects: </p><blockquote><ul><li><strong>Control</strong><br>The control right of current object.</li><li><strong>Inversion</strong><br>This control right is not ever managed by the current object, but by IOC container.  </li></ul></blockquote><p>Simply put, the effect of IOC is to hand over the objects we need to a third-party IOC container to generate and we do not need to care about how they are produced. All we need to do is focus on the implementation of code logic. Compared to developers manually creating objects, IOC reverses the power of creating objects, that is, this power is assigned to Spring. Using IOC has the following benefits:  </p><blockquote><ul><li><strong>No need to create new objects by yourself, dependency injection(DI) can be done in IOC container.</strong></li><li><strong>The objects we need can be defined in the configuration file. Unified configuration, easy to modify.</strong>  </li></ul></blockquote><p>The IOC container is actually a relationship network about beans built by Context, Core and Bean. The entry point of this relationship construction is in the <strong>refresh</strong> method of the <strong>AbstractApplicationContext</strong> class. Code is showed as below:</p><pre><code class="hljs bash">public void refresh() throws BeansException, IllegalStateException &#123;synchronized (this.startupShutdownMonitor) &#123;// Prepare this context <span class="hljs-keyword">for</span> refreshing.prepareRefresh(); // Tell the subclass to refresh the internal bean factory.ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare beanfactory to use this context. Do some preparatory work, such as classloader, beanfactoryPostProcessor, etc.prepareBeanFactory(beanFactory); try &#123;//Allow subclasses of context to execute postProcessorpostProcessBeanFactory(beanFactory); // Start execution of BeanFactoryPostProcessors registered to this contextinvokeBeanFactoryPostProcessors(beanFactory); // Start registering BeanPostProcessor to intercept the initialization process of other beansregisterBeanPostProcessors(beanFactory); // Initialize the message <span class="hljs-built_in">source</span>initMessageSource(); //Register a broadcast <span class="hljs-built_in">set</span> of contextual eventsinitApplicationEventMulticaster(); //Initialize some special beansonRefresh(); //Query and verify the listener and registerregisterListeners(); // Instantiate all beans that are non-lazy-initfinishBeanFactoryInitialization(beanFactory); //Publish all applicationsfinishRefresh();&#125; catch (BeansException ex) &#123;// Destroy already created singletons to avoid dangling resources.destroyBeans(); // Reset <span class="hljs-string">'active'</span> flag.cancelRefresh(ex); // Propagate exception to <span class="hljs-built_in">caller</span>.throw ex;&#125;&#125;&#125;</code></pre><p>The IOC container is actually a big factory, which is used to manage all our objects and dependencies. The principle is as follows：</p><blockquote><ul><li><strong>Through reflection we can get all the information of the class. That is, the bean is instantiated through the reflection factory pattern in the previous chapter.</strong>  </li><li><strong>Then describe the relationship between classes through configuration files or annotations.</strong></li><li><strong>Spring can automatically perform DI through the configuration of developer and reflection technology.</strong>  </li></ul></blockquote><h2 id="Spring-Container"><a href="#Spring-Container" class="headerlink" title="Spring Container"></a>Spring Container</h2><p>Spring container will be created in the <strong>refresh</strong> method. Now two Spring containers are defined, and the beans are actually produced from these two Spring containers:</p><blockquote><ul><li><strong>BeanFactory</strong><br>For the BeanFactory container, when a client requests a bean that has not been initialized from the container, or when another bean that needs to be injected uninitialized dependencies bean, the container will call <strong>createBean</strong> method to instantiate it. So very few resources are used when the application starts. But the application runs slower.</li><li><strong>ApplicationContext</strong><br>ApplicationContext implements the BeanFactory interface. Unlike BeanFactory, all the beans will be instantiated when the container is started. So it will take more time to start the application, but the application will run faster.  </li></ul></blockquote><p>The production process of beans in Spring containers:</p><blockquote><ul><li><strong>Create a bean definition registry inside the container based on the bean configuration information.</strong></li><li><strong>Load, instantiate beans according to the registry, and establish the dependency relationship between beans.</strong></li><li><strong>Put these ready beans in the Map cache pool and wait for the application to call.</strong>  </li></ul></blockquote><p>Almost all applications currently use <strong>ApplicationContext</strong>!  </p><h2 id="Life-Cycle-of-Bean"><a href="#Life-Cycle-of-Bean" class="headerlink" title="Life Cycle of Bean"></a>Life Cycle of Bean</h2><p>The Spring container can manage the life cycle of <strong>singleton</strong> scope beans. Under this scope, Spring can accurately know when the bean is created, when initialization is completed, and when it is destroyed.<br>But for Beans in <strong>prototype</strong> scope, Spring is only responsible for creating. When the container creates an instance of Bean, the instance of Bean is handed over to the client code management, and the Spring container will no longer track its life cycle. The Bean life cycle is shown in the figure below:<br><img src="/2020/07/15/Spring-Basic/Bean_life.png" srcset="/img/loading.gif" alt="Bean life cycle"></p><blockquote><ol><li>First read the configuration file resource, get <strong>BeanDefinition</strong> according to the configuration file, and then use reflection technology to instantiate Bean according to BeanDefinition. For the BeanFactory container and the ApplicationContext container, the timing of instantiating Beans is different, and the differences are listed in the previous chapters.</li><li>The instantiated object is encapsulated in the <strong>BeanWrapper</strong> object, and the object is still in a native state at this time, and no dependency injection is performed. Next, according to the information in BeanDefinition, Spring completes the dependency injection through the interface for setting properties provided by BeanWrapper.</li><li>If the Bean implements a series of <strong>Aware</strong> interfaces, the corresponding method will be called:<blockquote><ul><li>If the <strong>BeanNameAware</strong> interface is implemented, Spring will call the bean’s <strong>setBeanName()</strong> method to pass in the id value of the current bean.</li><li>If the bean implements the <strong>BeanFactoryAware</strong> interface, Spring will call the <strong>setBeanFactory()</strong> method to pass in a reference to the current factory instance.</li><li>If the Bean implements the <strong>ApplicationContextAware</strong> interface, Spring will call the <strong>setApplicationContext()</strong> method to pass in a reference to the current ApplicationContext instance.</li></ul></blockquote></li><li>After that, the bean object has been correctly constructed, but if you want to perform some custom processing before the object is used, you can achieve it through the BeanPostProcessor interface. If the beans implement the <strong>BeanPostProcess</strong> interface, Spring will call their <strong>postProcessBeforeInitialization()</strong> (pre-initialization) method. Its effect is to enhance the processing after the Bean instance is successfully created, such as modifying the Bean or adding a certain function.</li><li>If the Bean implements the <strong>InitializingBean</strong> interface, Spring will call the <strong>afterPropertiesSet()</strong> method. This is an initialization method that is executed after all the properties of the Bean are set successfully.</li><li>If the initialization method is specified by the <strong>init-method</strong> attribute in the <strong>configuration file</strong>, this initialization method will be called.</li><li>Similar to <strong>4</strong>, after the Bean is initialized, if the <strong>BeanPostProcessor</strong> interface is implemented, Spring will call the initialization method <strong>postProcessAfterInitialization()</strong> (post-initialization) of the interface. At this point, the Bean can already be used by the application system.</li><li>If the <strong>scope of the bean</strong> is specified as scope=”singleton” in <bean>, putting the bean into the cache pool of Spring container will trigger Spring’s life cycle management of the bean. If the scope of the bean is specified as scope=”prototype”, the bean is given to the caller. The caller manages the life cycle of the bean and Spring no longer manages the bean.</bean></li><li>If the bean implements the <strong>DisposableBean</strong> interface, Spring will call the <strong>destroy()</strong> method to destroy the bean in Spring. If the destruction method of the bean is specified through the <strong>destory-method</strong> attribute in the configuration file, Spring will call this method to destroy the bean.  </li></ol></blockquote><h2 id="Scope-of-Bean"><a href="#Scope-of-Bean" class="headerlink" title="Scope of Bean"></a>Scope of Bean</h2><p>When the Spring container initializes an instance of Bean, it also specifies the scope of the instance. Spring defines five scopes for Bean:  </p><blockquote><ul><li><strong>singleton:</strong> Singleton mode, the bean defined by singleton has only one instance in the Spring container, which is the default scope of the bean.</li><li><strong>prototype:</strong> Prototype mode, each time the Bean defined by prototype is obtained through the Spring container, the container will create a new Bean instance.</li><li><strong>request:</strong> In an HTTP request, the container returns the same instance of the bean. For different HTTP requests, different instances will be returned. This scope is only valid in the current HTTP Request. </li><li><strong>session:</strong> In an HTTP Session, the container will return the same instance of the bean. For different HTTP requests, different instances will be returned. This scope is only valid in the current HTTP Session. </li><li><strong>global Session:</strong> In a global HTTP Session, the container will return the same instance of the bean. This scope is only valid when using portlet context.  </li></ul></blockquote><p>Among the above five scopes, <strong>singleton</strong> and <strong>prototype</strong> are the two most commonly used. From the life cycle of Bean in the previous chapter, we can see that the life cycle of Bean is slightly different when setting different scopes for Bean. For <strong>request, session and global Session</strong> scope, Bean will be destroyed after its dependent environment disappears.</p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
