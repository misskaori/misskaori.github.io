<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring Basic - AOP</title>
    <link href="/2020/07/21/Spring-Basic-AOP/"/>
    <url>/2020/07/21/Spring-Basic-AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Basic-AOP"><a href="#Spring-Basic-AOP" class="headerlink" title="Spring Basic - AOP"></a>Spring Basic - AOP</h1><p><strong>Aspect Oriented Programming(AOP)</strong> is a continuation of (Object Oriented Programming)OOP. In the development process, business functions can be divided into core functions and non-core functions. The core functions are directly implemented in the business logic, while the non-core functions can be designed as a single aspect, and when needed It can be woven directly into the core function when it is used. This has the following advantages:</p><blockquote><ul><li><strong>Reduce code coupling. Aspect code and core business code are not coupled, which is convenient for maintenance.</strong></li><li><strong>Aspect code is easy to reuse.</strong></li></ul></blockquote><h2 id="Proxy-Modes-in-JAVA"><a href="#Proxy-Modes-in-JAVA" class="headerlink" title="Proxy Modes in JAVA"></a>Proxy Modes in JAVA</h2><p><strong>Spring AOP</strong> is implemented based on JDK dynamic proxy and CGLIB proxy. The proxy mode can enhance the function of the target class. There are 3 proxy modes in JAVA: <strong>Static proxy, JDK dynamic proxy, and CGLIB proxy</strong>.</p><h3 id="Static-Proxy"><a href="#Static-Proxy" class="headerlink" title="Static Proxy"></a>Static Proxy</h3><p>Static proxy is only applicable to target classes that <strong>implement certain interfaces or inherit a certain parent class.</strong> Then design the proxy class to implement the above interface or inherit the same parent class, and enhance the function in the method of the proxy class. For example:  </p><p><strong>Interface Design: IUserDao</strong></p><pre><code class="hljs bash">public interface IUserDao &#123;    void save();&#125;</code></pre><p><strong>Target Object: UserDao</strong>  </p><pre><code class="hljs bash">\\Implemented the IUserDao interfacepublic class UserDao implements IUserDao &#123;    @Override    public void <span class="hljs-function"><span class="hljs-title">save</span></span>() &#123;        System.out.println(<span class="hljs-string">"----Core Business----"</span>);    &#125;&#125;</code></pre><p><strong>Proxy Class: UserDaoProxy</strong></p><pre><code class="hljs bash">/** * Static Proxy */public class UserDaoProxy implements IUserDao&#123;    //Accept the target object    private IUserDao target;    public UserDaoProxy(IUserDao target)&#123;        this.target=target;    &#125;    //Enhance the target object method    public void <span class="hljs-function"><span class="hljs-title">save</span></span>() &#123;        System.out.println(<span class="hljs-string">"Begin..."</span>);        target.save();//Perform core business        System.out.println(<span class="hljs-string">"End..."</span>);    &#125;&#125;</code></pre><p><strong>MainTest</strong></p><pre><code class="hljs bash">/** * Test Class */public class MainTest &#123;    public static void main(String[] args) &#123;        //Target object        UserDao target = new UserDao();        //Deliver the target object to the proxy object        UserDaoProxy proxy = new UserDaoProxy(target);        proxy.save();//Implementation of the enhanced proxy method    &#125;&#125;</code></pre><p><strong>Result</strong></p><pre><code class="hljs bash">Begin...----Core Business----End...</code></pre><p><strong>Class Inheritance</strong><br><img src="/2020/07/21/Spring-Basic-AOP/Package_Test.png" srcset="/img/loading.gif" alt="Static Proxy Class Inheritance"><br>Although the static proxy method can realize the enhancement of the target class function without changing the target class method, it has an <strong>obvious disadvantage:</strong>  </p><blockquote><ul><li><strong>In actual applications, there may be many interfaces and static proxy classes. Since the static proxy class must implement the interface of the target class, when the interface method changes, all proxy classes and target classes must be maintained costly.</strong></li></ul></blockquote><h3 id="JDK-Dynamic-Proxy"><a href="#JDK-Dynamic-Proxy" class="headerlink" title="JDK Dynamic Proxy"></a>JDK Dynamic Proxy</h3><p>JDK dynamic proxy has the following characteristics:</p><blockquote><ul><li><strong>The proxy class does not need to manually implement interfaces and methods.</strong></li><li><strong>The generation of proxy objects uses the JDK API to dynamically build proxy objects in computer memory.</strong>  </li><li><strong>The target class must implement the interface.</strong>  </li></ul></blockquote><p>JDK dynamic proxy is the main implementation form of Spring AOP. The entry point of the dynamic construction proxy class is <strong>JDK: java.lang.reflect.Proxy.</strong> The structure of this class is shown in the figure below:<br><img src="/2020/07/21/Spring-Basic-AOP/Proxy_Structure.png" srcset="/img/loading.gif" alt="Dynamic Proxy_Structure"><br>The method marked in the figure is: <strong>newProxyInstance()</strong>. Dynamic proxy objects are created using this method. The source code of this method is as follows:  </p><pre><code class="hljs bash">public static Object newProxyInstance(ClassLoader loader,                                      Class&lt;?&gt;[] interfaces,                                      InvocationHandler h)    throws IllegalArgumentException&#123;    Objects.requireNonNull(h);    final Class&lt;?&gt;[] intfs = interfaces.clone();    final SecurityManager sm = System.getSecurityManager();    <span class="hljs-keyword">if</span> (sm != null) &#123;        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &#125;    /*     * Look up or generate the designated proxy class.     */    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    /*     * Invoke its constructor with the designated invocation handler.     */    try &#123;        <span class="hljs-keyword">if</span> (sm != null) &#123;            checkNewProxyPermission(Reflection.getCallerClass(), cl);        &#125;        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);        final InvocationHandler ih = h;        <span class="hljs-keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                public Void <span class="hljs-function"><span class="hljs-title">run</span></span>() &#123;                    cons.setAccessible(<span class="hljs-literal">true</span>);                    <span class="hljs-built_in">return</span> null;                &#125;            &#125;);        &#125;        <span class="hljs-built_in">return</span> cons.newInstance(new Object[]&#123;h&#125;);    &#125; catch (IllegalAccessException|InstantiationException e) &#123;        throw new InternalError(e.toString(), e);    &#125; catch (InvocationTargetException e) &#123;        Throwable t = e.getCause();        <span class="hljs-keyword">if</span> (t instanceof RuntimeException) &#123;            throw (RuntimeException) t;        &#125; <span class="hljs-keyword">else</span> &#123;            throw new InternalError(t.toString(), t);        &#125;    &#125; catch (NoSuchMethodException e) &#123;        throw new InternalError(e.toString(), e);    &#125;&#125;</code></pre><p>This method requires 3 parameters:</p><blockquote><ul><li><strong>ClassLoader:</strong> Loader class for loading proxy class. Usually this Loader is same as target class’s Loader class.</li><li><strong>Interfaces:</strong> The interfaces to be implemented by the proxy class. That is, the collection of interfaces implemented by the target class.</li><li><strong>InvocationHandler:</strong> Used to perform user-defined operations other than methods in the proxy interface. The target method called by the user is proxied to InvocationHandler’s invoke() method.  </li></ul></blockquote><p>The source code of <strong>InvocationHandler</strong> is as follows:</p><pre><code class="hljs bash">public interface InvocationHandler &#123;    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Basic - Bean and IOC</title>
    <link href="/2020/07/15/Spring-Basic/"/>
    <url>/2020/07/15/Spring-Basic/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Basic-Bean-and-IOC"><a href="#Spring-Basic-Bean-and-IOC" class="headerlink" title="Spring Basic - Bean and IOC"></a>Spring Basic - Bean and IOC</h1><p>The Spring framework consists of three core components:</p><blockquote><ul><li><strong>Context</strong><br>The role of Context is to discover the relationship between each Bean. And it will establish and maintain this relationship for beans. So Context is a collection of Bean relationships, this relationship combination is also known as the IOC container.  </li><li><strong>Core</strong><br>The role of the Core is to discover, establish and maintain a series of tools needed for the relationship between each Bean.</li><li><strong>Bean</strong><br>Bean is the most core component in Spring. In fact, Spring is Bean oriented programming(BOP). Spring wraps Object in Bean, and then implements a series of operations on Bean to achieve dependency injection(DI).  </li></ul></blockquote><p>This blog will mainly explain the generation mode and life cycle of Bean. After that, it can be easier to understand the implementation mechanism of Spring IOC.</p><h2 id="The-Instantiation-Mode-of-Bean"><a href="#The-Instantiation-Mode-of-Bean" class="headerlink" title="The Instantiation Mode of Bean"></a>The Instantiation Mode of Bean</h2><p>The creation of Spring Bean is a typical factory pattern. And the factory uses reflection technology to instantiate Bean. Compared with the ordinary factory model, the use of reflection technology can effectively improve the flexibility and maintainability of Spring source code.<br>First of all, let us take a look at the factory mode when <strong>reflection technology is not used</strong>.  </p><pre><code class="hljs bash">interface fruit&#123;    public abstract void eat();&#125; class Apple implements fruit&#123;     public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;         System.out.println(<span class="hljs-string">"Apple"</span>);     &#125;&#125; class Orange implements fruit&#123;     public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;         System.out.println(<span class="hljs-string">"Orange"</span>);     &#125;&#125;class Factory&#123;     public static fruit getInstance(String fruitName)&#123;         fruit f=null;         //Factory can product new <span class="hljs-built_in">type</span> instances by adding the following conditional statements         <span class="hljs-keyword">if</span>(<span class="hljs-string">"Apple"</span>.equals(fruitName))&#123;             f=new Apple();         &#125;         <span class="hljs-keyword">if</span>(<span class="hljs-string">"Orange"</span>.equals(fruitName))&#123;             f=new Orange();         &#125;         <span class="hljs-built_in">return</span> f;     &#125;&#125;//Using factory pattern to build instanceclass hello&#123;     public static void main(String[] a)&#123;         fruit f=Factory.getInstance(<span class="hljs-string">"Orange"</span>);         f.eat();     &#125;&#125;</code></pre><p>In the future, every time you want the factory to produce a new type instance, you need to override the factory method. If there are too many kinds of new subclasses to be added, the changes to the factory will be very large.<br>Next let us take a look at the factory mode when <strong>reflection technology is used</strong>.</p><pre><code class="hljs bash">interface fruit&#123;     public abstract void eat();&#125;class Apple implements fruit&#123;public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;         System.out.println(<span class="hljs-string">"Apple"</span>);     &#125;&#125;class Orange implements fruit&#123;public void <span class="hljs-function"><span class="hljs-title">eat</span></span>()&#123;        System.out.println(<span class="hljs-string">"Orange"</span>);    &#125;&#125;class Factory&#123;    public static fruit getInstance(String ClassName)&#123;        fruit f=null;        try&#123;            //Construct a new instance from a string of class name            f=(fruit)Class.forName(ClassName).newInstance();        &#125;catch (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-built_in">return</span> f;    &#125;&#125;//Using factory pattern to build instanceclass hello&#123;    public static void main(String[] a)&#123;        //Enter string of class name        fruit f=Factory.getInstance(<span class="hljs-string">"Reflect.Apple"</span>);        <span class="hljs-keyword">if</span>(f!=null)&#123;            f.eat();        &#125;    &#125;&#125;</code></pre><p>After using the reflection technology, we no longer need to rewrite the factory method, the reflection technology will map the internal attribute method of the class into a Java object based on the bytecode information of the class. <strong>So this kind of factory model is more maintainable for developer</strong>. The IOC container uses this factory model and produces the objects we need according to the definition of the configuration file. But compared to the normal way of producing objects, the speed of reflection generation will be <strong>slower</strong>. There are three ways to instantiate Bean:  </p><blockquote><ul><li><strong>Constructor instantiation:</strong> Constructor instantiation means that the IOC container instantiates the bean through the default constructor in the class corresponding to the bean.</li><li><strong>Static factory instantiation:</strong> In Spring, you can also use static factories to instantiate beans. This method needs to provide a static factory method to create an instance of Bean.</li><li><strong>Instance factory instantiation:</strong> In Spring, there is another way to instantiate beans by using an instance factory. In this way, the factory class no longer uses static methods to create Bean instances, but directly creates Bean instances in member methods.  </li></ul></blockquote><p>After instantiation, the IOC container needs to inject dependency into Bean, DI has two ways: </p><blockquote><ul><li><strong>Property setter injection:</strong> Call the setter method of the bean to implement DI. </li><li><strong>Constructor injection:</strong> Call the constructor with parameters, each parameter represents a dependency.</li></ul></blockquote><h2 id="Inversion-of-Control-IOC"><a href="#Inversion-of-Control-IOC" class="headerlink" title="Inversion of Control - IOC"></a>Inversion of Control - IOC</h2><p>IOC (Inversion of Control) contains two aspects: </p><blockquote><ul><li><strong>Control</strong><br>The control right of current object.</li><li><strong>Inversion</strong><br>This control right is not ever managed by the current object, but by IOC container.  </li></ul></blockquote><p>Simply put, the effect of IOC is to hand over the objects we need to a third-party IOC container to generate and we do not need to care about how they are produced. All we need to do is focus on the implementation of code logic. Compared to developers manually creating objects, IOC reverses the power of creating objects, that is, this power is assigned to Spring. Using IOC has the following benefits:  </p><blockquote><ul><li><strong>No need to create new objects by yourself, dependency injection(DI) can be done in IOC container.</strong></li><li><strong>The objects we need can be defined in the configuration file. Unified configuration, easy to modify.</strong>  </li></ul></blockquote><p>The IOC container is actually a relationship network about beans built by Context, Core and Bean. The entry point of this relationship construction is in the <strong>refresh</strong> method of the <strong>AbstractApplicationContext</strong> class. Code is showed as below:</p><pre><code class="hljs bash">public void refresh() throws BeansException, IllegalStateException &#123;synchronized (this.startupShutdownMonitor) &#123;// Prepare this context <span class="hljs-keyword">for</span> refreshing.prepareRefresh(); // Tell the subclass to refresh the internal bean factory.ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare beanfactory to use this context. Do some preparatory work, such as classloader, beanfactoryPostProcessor, etc.prepareBeanFactory(beanFactory); try &#123;//Allow subclasses of context to execute postProcessorpostProcessBeanFactory(beanFactory); // Start execution of BeanFactoryPostProcessors registered to this contextinvokeBeanFactoryPostProcessors(beanFactory); // Start registering BeanPostProcessor to intercept the initialization process of other beansregisterBeanPostProcessors(beanFactory); // Initialize the message <span class="hljs-built_in">source</span>initMessageSource(); //Register a broadcast <span class="hljs-built_in">set</span> of contextual eventsinitApplicationEventMulticaster(); //Initialize some special beansonRefresh(); //Query and verify the listener and registerregisterListeners(); // Instantiate all beans that are non-lazy-initfinishBeanFactoryInitialization(beanFactory); //Publish all applicationsfinishRefresh();&#125; catch (BeansException ex) &#123;// Destroy already created singletons to avoid dangling resources.destroyBeans(); // Reset <span class="hljs-string">'active'</span> flag.cancelRefresh(ex); // Propagate exception to <span class="hljs-built_in">caller</span>.throw ex;&#125;&#125;&#125;</code></pre><p>The IOC container is actually a big factory, which is used to manage all our objects and dependencies. The principle is as follows：</p><blockquote><ul><li><strong>Through reflection we can get all the information of the class. That is, the bean is instantiated through the reflection factory pattern in the previous chapter.</strong>  </li><li><strong>Then describe the relationship between classes through configuration files or annotations.</strong></li><li><strong>Spring can automatically perform DI through the configuration of developer and reflection technology.</strong>  </li></ul></blockquote><h2 id="IOC-container"><a href="#IOC-container" class="headerlink" title="IOC container"></a>IOC container</h2><p>Now two kinds of IOC containers are defined, and the beans are actually produced from these two IOC containers:</p><blockquote><ul><li><strong>BeanFactory</strong><br>For the BeanFactory container, when a client requests a bean that has not been initialized from the container, or when another bean that needs to be injected uninitialized dependencies bean, the container will call <strong>createBean</strong> method to instantiate it. So very few resources are used when the application starts. But the application runs slower.</li><li><strong>ApplicationContext</strong><br>ApplicationContext implements the BeanFactory interface. Unlike BeanFactory, all the beans will be instantiated when the container is started. So it will take more time to start the application, but the application will run faster.  </li></ul></blockquote><p>The production process of beans in IOC containers:</p><blockquote><ul><li><strong>Create a bean definition registry inside the container based on the bean configuration information.</strong></li><li><strong>Load, instantiate beans according to the registry, and establish the dependency relationship between beans.</strong></li><li><strong>Put these ready beans in the Map cache pool and wait for the application to call.</strong>  </li></ul></blockquote><p>Almost all applications currently use <strong>ApplicationContext</strong>!  </p><h2 id="Life-Cycle-of-Bean"><a href="#Life-Cycle-of-Bean" class="headerlink" title="Life Cycle of Bean"></a>Life Cycle of Bean</h2><p>The IOC container can manage the life cycle of <strong>singleton</strong> scope beans. Under this scope, Spring can accurately know when the bean is created, when initialization is completed, and when it is destroyed.<br>But for Beans in <strong>prototype</strong> scope, Spring is only responsible for creating. When the container creates an instance of Bean, the instance of Bean is handed over to the client code management, and the IOC container will no longer track its life cycle. The Bean life cycle is shown in the figure below:<br><img src="/2020/07/15/Spring-Basic/Bean_life.png" srcset="/img/loading.gif" alt="Bean life cycle"></p><blockquote><ol><li>First read the configuration file resource, get <strong>BeanDefinition</strong> according to the configuration file, and then use <strong>Java Reflection API</strong> to instantiate Bean according to BeanDefinition. For the BeanFactory container and the ApplicationContext container, the timing of instantiating Beans is different, and the differences are listed in the previous chapters.</li><li>The instantiated object is encapsulated in the <strong>BeanWrapper</strong> object, and the object is still in a native state at this time, and no dependency injection is performed. Next, according to the information in BeanDefinition, Spring completes the dependency injection through the interface for setting properties provided by BeanWrapper.</li><li>If the Bean implements a series of <strong>Aware</strong> interfaces, the corresponding method will be called:<blockquote><ul><li>If the <strong>BeanNameAware</strong> interface is implemented, Spring will call the bean’s <strong>setBeanName()</strong> method to pass in the id value of the current bean.</li><li>If the bean implements the <strong>BeanFactoryAware</strong> interface, Spring will call the <strong>setBeanFactory()</strong> method to pass in a reference to the current factory instance.</li><li>If the Bean implements the <strong>ApplicationContextAware</strong> interface, Spring will call the <strong>setApplicationContext()</strong> method to pass in a reference to the current ApplicationContext instance.</li></ul></blockquote></li><li>After that, the bean object has been correctly constructed, but if you want to perform some custom processing before the object is used, you can achieve it through the BeanPostProcessor interface. If the beans implement the <strong>BeanPostProcess</strong> interface, Spring will call their <strong>postProcessBeforeInitialization()</strong> (pre-initialization) method. Its effect is to enhance the processing after the Bean instance is successfully created, such as modifying the Bean or adding a certain function.</li><li>If the Bean implements the <strong>InitializingBean</strong> interface, Spring will call the <strong>afterPropertiesSet()</strong> method. This is an initialization method that is executed after all the properties of the Bean are set successfully.</li><li>If the initialization method is specified by the <strong>init-method</strong> attribute in the <strong>configuration file</strong>, this initialization method will be called.</li><li>Similar to <strong>4</strong>, after the Bean is initialized, if the <strong>BeanPostProcessor</strong> interface is implemented, Spring will call the initialization method <strong>postProcessAfterInitialization()</strong> (post-initialization) of the interface. At this point, the Bean can already be used by the application system.</li><li>If the <strong>scope of the bean</strong> is specified as scope=”singleton” in <bean>, putting the bean into the cache pool of IOC container will trigger Spring’s life cycle management of the bean. If the scope of the bean is specified as scope=”prototype”, the bean is given to the caller. The caller manages the life cycle of the bean and Spring no longer manages the bean.</bean></li><li>If the bean implements the <strong>DisposableBean</strong> interface, Spring will call the <strong>destroy()</strong> method to destroy the bean in Spring. If the destruction method of the bean is specified through the <strong>destory-method</strong> attribute in the configuration file, Spring will call this method to destroy the bean.  </li></ol></blockquote><h2 id="Scope-of-Bean"><a href="#Scope-of-Bean" class="headerlink" title="Scope of Bean"></a>Scope of Bean</h2><p>When the IOC container initializes an instance of Bean, it also specifies the scope of the instance. Spring defines five scopes for Bean:  </p><blockquote><ul><li><strong>singleton:</strong> Singleton mode, the bean defined by singleton has only one instance in the IOC container, which is the default scope of the bean.</li><li><strong>prototype:</strong> Prototype mode, each time the Bean defined by prototype is obtained through the IOC container, the container will create a new Bean instance.</li><li><strong>request:</strong> In an HTTP request, the container returns the same instance of the bean. For different HTTP requests, different instances will be returned. This scope is only valid in the current HTTP Request. </li><li><strong>session:</strong> In an HTTP Session, the container will return the same instance of the bean. For different HTTP requests, different instances will be returned. This scope is only valid in the current HTTP Session. </li><li><strong>global Session:</strong> In a global HTTP Session, the container will return the same instance of the bean. This scope is only valid when using portlet context.  </li></ul></blockquote><p>Among the above five scopes, <strong>singleton</strong> and <strong>prototype</strong> are the two most commonly used. From the life cycle of Bean in the previous chapter, we can see that the life cycle of Bean is slightly different when setting different scopes for Bean. For <strong>request, session and global Session</strong> scope, Bean will be destroyed after its dependent environment disappears.  </p><h2 id="Extension-Point-of-IOC-Container"><a href="#Extension-Point-of-IOC-Container" class="headerlink" title="Extension Point of IOC Container"></a>Extension Point of IOC Container</h2><p>The IOC container has the following extension points. Through these interfaces, users can add some custom operations.</p><blockquote><ul><li><strong>BeanFactoryPostProcessor:</strong> Called when building the BeanFactory object.</li><li><strong>BeanPostProcessor:</strong> <strong>postProcessBeforeInitialization() and postProcessAfterInitialization()</strong> are called when building the Bean object.</li><li><strong>InitializingBean:</strong> <strong>afterPropertiesSet()</strong> is called before init-method.</li><li><strong>DisposableBean:</strong> <strong>destroy()</strong> is called when destroying the bean object.</li><li><strong>FactoryBean:</strong> When a bean managed by the IOC container implements the FactoryBean interface, in the getBean() phase, Spring will call the bean’s <strong>getObejct()</strong> method and the return is not its own instance. Equivalent to the getObject() in FactoryBean is getBean’s proxy method. This means that users can customize the Bean they want through FactoryBean interface.  </li></ul></blockquote><p>Application examples of <strong>FactoryBean</strong>:<br>If you use the traditional way to configure the <bean> of the following Car class, each attribute of Car corresponds to a <property> element tag. The attributes of Car is: <strong>maxSpeed, brand, price.</strong>  </property></bean></p><pre><code class="hljs bash">public class Car  &#123;     private   int maxSpeed ; private String brand ; private   double price ;      ...//get/<span class="hljs-built_in">set</span> method ｝</code></pre><p>It will be more flexible if implemented by FactoryBean interface. In <strong>getObject()</strong>, you can specify configuration values for all attributes of Car at one time:  </p><pre><code class="hljs bash">public class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123;      private String carInfo;      public Car getObject() throws Exception &#123;        Car car = new Car();        String[] infos = carInfo.split(<span class="hljs-string">","</span>);        //Set the attributes of Car        car.setBrand(infos[0]);        car.setMaxSpeed(Integer.valueOf(infos[1]));        car.setPrice(Double.valueOf(infos[2])); <span class="hljs-built_in">return</span> car;    &#125;    public Class&lt;Car&gt; <span class="hljs-function"><span class="hljs-title">getObjectType</span></span>() &#123;       <span class="hljs-built_in">return</span> Car.class;    &#125;    public boolean <span class="hljs-function"><span class="hljs-title">isSingleton</span></span>() &#123;      <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;   &#125; &#125;</code></pre><p>With this CarFactoryBean, you can configure the Car Bean using the following custom configuration method in the configuration file:  </p><pre><code class="hljs bash">&lt;bean id=<span class="hljs-string">"car"</span> class=<span class="hljs-string">"com.test.factorybean.CarFactoryBean"</span> carInfo=<span class="hljs-string">"BenzSUV,180,180000"</span>/&gt;</code></pre><p>When getBean(“Car”) is called, Spring finds that CarFactoryBean implements the FactoryBean interface through the reflection mechanism, and then the Spring container calls the interface method CarFactoryBean.getObject() method to return. If you want to get an instance of CarFactoryBean, you need to add the “&amp;” before the beanName when using the getBean(beanName) method, for example: getBean(“&amp;car”).</p>]]></content>
    
    
    <categories>
      
      <category>Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
